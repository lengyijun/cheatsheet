#include<limits.h>
int a=INT_MIN

# custom compare
std::sort(std::begin(container), std::end(container),
          [] (const auto& lhs, const auto& rhs) {
    return lhs.first < rhs.first;
});

//priority_queue默认是最大值在前面
//最小堆
priority_queue<int, vector<int>, greater<int> > q;

//字符串匹配
s1.find(s2) != std::string::npos

//unique
std::vector<int> v{1,2,1,1,3,3,3,4,5,4};
auto last = std::unique(v.begin(), v.end());
// v now holds {1 2 1 3 4 5 4 x x x}, where 'x' is indeterminate
v.erase(last, v.end());

// subset of binary
for (int cs = (a - 1) & a; cs; cs = (cs - 1) & a) {
  cout<<cs<<endl;
}

lower_bound
upper_bound
默认数组从小到大排序。如果是从大到小排序，需要加个参数
左开右闭。右边一般是 v.end() 这种访问不了的地方
如果返回右区间，表明没有查询到
使用的时候，想想好是不是一定能找的到。如果一定能找的到，那也不用额外判断了

# 在单调递增序列中，x的个数
upper_bound(a,a+n,x)-lower_bound(a,a+n,x)

# delete one item
multiset.erase(iterator)

# delete all items
multiset.erase(1)

#include <bits/stdc++.h>

std::sort(v.begin(), v.end(), [](int a,int b){return (a % 10) > (b % 10);}); 
可能你还不太会使用 Lambda，基本形式如下：[](argument1,argument2,.....){//code}
在 () 中传入参数，在 {} 中编写代码，[] 是一个捕获列表，可以指定外部作用域中，可以使用的局部变量：
[] — 捕获列表为空，表示在 lambda 表达式中不能使用任何外部作用域的局部变量，只能使用传进去的参数。
[=] — 表示按照值传递的方法捕获父作用域的所有变量。
[&] — 表示按照引用传递的方法捕获父作用域的所有变量。
[this] — 在成员函数中，按照值传递的方法捕获 this 指针。
[a, &b] — 不建议直接使用 [=] 或 [&] 捕获所有变量，可以按需显式捕获，就是在 [] 指定变量名，[a] 表示值传递，[&b] 表示引用传递。

int mi = std::min({x1, x2, x3, x4})

set,map: 红黑树
unordered_map: hash table
所以set和map的key可以是vector
而unordered_map的key不能是vector

//ok
set<vector<int> > s;
map<vector<int>,int> mp;

//error
unordered_map<vector<int>,int> mp;

memcpy,memmove
在遇到src和dest重叠的情况下，memcpy不能保证正确性，memmove可以保证正确性


// priority_queue 自定义方法1
struct Node{
    int x, y;
    Node(int a=0, int b=0):
        x(a),y(b){}
};
bool operator<(Node a, Node b){//返回true时，说明a的优先级低于b
    //x值较大的Node优先级低（x小的Node排在队前）
    //x相等时，y大的优先级低（y小的Node排在队前）
    if( a.x== b.x ) return a.y> b.y;
    return a.x> b.x;
}
priority_queue<Node> pq;

// priority_queue 自定义方法2
auto comp=[](ListNode *a, ListNode *b) {return a->vl > b->val;};
priority_queue<ListNode*, vector<ListNode*>, decltype(comp)> q(comp);
